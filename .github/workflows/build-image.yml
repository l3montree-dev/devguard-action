on:
  workflow_call:
    inputs:
      image-destination-path:
        description: 'Destination of the image.tar file'
        type: string
        required: false
        default: "image.tar"
      image:
        description: 'OCI image name, includes the tag name'
        type: string
        required: false
      asset-name:
        description: 'Name of the asset'
        type: string
        required: true
      api-url:
        description: 'URL of the DevGuard API'
        type: string
        required: false
        default: "https://api.main.devguard.org"
      image-suffix:
        description: 'Suffix for the image name. You probably need this if you are building multiple images. For example building a -scanner image and a -web image.'
        type: string
        required: false
        default: ""
      artifact-suffix:
        description: 'This is only needed if you are using this job multiple times in the same workflow. For example if you are building multiple images from the same source with different configuration.'
        type: string
        required: false
        default: ""
      disable_artifact_registry_as_image_store:
        required: false
        default: "false"
        type: string
        description: "If the artifact size is too big for your gitlab instance, set this to true. This will push the image directly to the registry instead of uploading it as artifact."
    secrets:
      devguard-token:
        description: 'DevGuard API token'
        required: true
      build-args:
        description: 'Build arguments. Useful to overwrite context and dockerfile. Maybe even add additional build args.'
        required: false

jobs:
  build-image:
    runs-on: ubuntu-latest
    steps:
    - name: Set BUILD_ARGS
      run: |
        if [ -z "${{ secrets.build-args }}" ]; then
          echo "BUILD_ARGS=--context=. --dockerfile=Dockerfile"
        else
          echo "BUILD_ARGS=${{ secrets.build-args }}"
        fi

        # check if we should use the artifact storage or the container registry
        if [ "${{ inputs.disable_artifact_registry_as_image_store }}" == "false" ]; then
          echo "BUILD_ARGS=$BUILD_ARGS --no-push --tarPath /github/workspace/tmp-image.tar" >> $GITHUB_ENV
        else
          echo "BUILD_ARGS=$BUILD_ARGS >> $GITHUB_ENV"
        fi
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        persist-credentials: false
    - name: In-Toto Provenance record start
      id: in-toto-start
      uses: docker://ghcr.io/l3montree-dev/devguard-scanner:main-latest
      with:
        args: devguard-scanner intoto start --step=build --token=${{ secrets.devguard-token }} --apiUrl=${{ inputs.api-url }} --assetName=${{ inputs.asset-name }} --supplyChainId=${{ github.sha }}
      continue-on-error: true

    # Calculate a tag name
    # If the image input is provided, use it as the tag
    # If the workflow is triggered by a tag, use the tag as the tag
    # Otherwise built GitOps compatible tags. Fallback to the branch name, commit hash, and timestamp. Those tags are sortable and  unique.
    - name: Set IMAGE_TAG
      run: |
        if [ "${IMAGE}" != "" ]; then
          IMAGE_TAG="${IMAGE}"
        elif [[ "${GITHUB_REF}" == refs/tags/* ]]; then
          IMAGE_TAG="ghcr.io/${{ github.repository }}${IMAGE_SUFFIX}:${GITHUB_REF#refs/tags/}"
        else
          branch=${GITHUB_REF##*/}
          sha=${GITHUB_SHA::8}
          ts=$(date +%s)
          IMAGE_TAG="ghcr.io/${{ github.repository }}${IMAGE_SUFFIX}:${branch}-${sha}-${ts}"
        fi

        IMAGE_TAG=$(echo "$IMAGE_TAG" | tr '[:upper:]' '[:lower:]')
        echo "$IMAGE_TAG" > image-tag.txt

        # necessary for the kaniko job
        echo "IMAGE_TAG=$(cat image-tag.txt)" >> $GITHUB_ENV
      env:
        IMAGE_SUFFIX: ${{ inputs.image-suffix }}
        IMAGE: ${{ inputs.image }}

    - name: Build Docker image with Kaniko
      # Building the Docker image using Kaniko
      id: build_image
      uses: docker://gcr.io/kaniko-project/executor:v1.23.0
      with:
        args: ${{ env.BUILD_ARGS }}

    - name: Move the image.tar to the destination path
      run: mv tmp-image.tar "${IMAGE_DESTINATION_PATH}"
      env:
        IMAGE_DESTINATION_PATH: ${{ inputs.image-destination-path }}
      # we only need this if we are using the artifact storage
      if: ${{ inputs.disable_artifact_registry_as_image_store }} == 'false'

    - name: Setup crane
      uses: imjasonh/setup-crane@v0.1

    - name: Use crane to get the digest
      run: |
        # check if we need to get the digest from a file or from the registry
        if [ "${{ inputs.disable_artifact_registry_as_image_store }}" == "true" ]; then
          crane digest $(cat image-tag.txt) > image-digest.txt
        else
          crane digest --tarball="${IMAGE_DESTINATION_PATH}" > image-digest.txt
        fi
      env:
        IMAGE_DESTINATION_PATH: ${{ inputs.image-destination-path }}

    # Uploading the built Docker image as an artifact
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: oci-image${{ inputs.artifact-suffix }}
        path: ${{ inputs.image-destination-path }}
      if: ${{ inputs.disable_artifact_registry_as_image_store }} == 'false'

    # Uploading the built Docker image digest as an artifact
    - name: Upload digest
      uses: actions/upload-artifact@v4
      with:
        name: image-digest${{ inputs.artifact-suffix }}
        path: image-digest.txt

    # Upload the calculated image tag as an artifact
    - name: Upload image tag
      uses: actions/upload-artifact@v4
      with:
        name: image-tag${{ inputs.artifact-suffix }}
        path: image-tag.txt

    - name: In-Toto Provenance record stop
      uses: docker://ghcr.io/l3montree-dev/devguard-scanner:main-latest
      with:
        args: devguard-scanner intoto stop --step=build --products=image-digest.txt --products=image-tag.txt --token=${{ secrets.devguard-token }} --apiUrl=${{ inputs.api-url }} --assetName=${{ inputs.asset-name }} --supplyChainId=${{ github.sha }} --generateSlsaProvenance
      continue-on-error: true
      
    - name: Upload SLSA Provenance
      uses: actions/upload-artifact@v4
      with:
        path: build.provenance.json
        name: build${{ inputs.artifact-suffix }}.provenance.json
